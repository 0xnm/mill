package build

import mill._, kotlinlib._
import mill.util.Jvm
import mill.api.Loose

object `package` extends RootModule with KotlinModule {

  def kotlinVersion = "1.9.24"

  // TODO extract this as Detekt module, similar to CheckstyleModule
  /**
   * Runs [[https://detekt.dev/docs/gettingstarted/cli Detekt]]
   */
  def detekt(): Command[Unit] = T.command {
    val exitCode = detekt0()()

    detektHandleErrors(exitCode)
  }

  private def detekt0() = T.task {

    val args = Seq("-i", PathRef(T.workspace).path.toString()) ++
      Seq("-c", PathRef(T.workspace / "detekt-config.yml").path.toString())

    T.log.info("running detekt ...")
    T.log.debug(s"with $args")

    Jvm.callSubprocess(
      mainClass = "io.gitlab.arturbosch.detekt.cli.Main",
      classPath = detektClasspath().map(_.path),
      mainArgs = args,
      workingDir = millSourcePath, // allow passing relative paths for sources like src/a/b
      streamOut = true,
      check = false
    ).exitCode
  }

  private def detektHandleErrors(exitCode: Int)(implicit ctx: mill.api.Ctx) = {

    if (exitCode == 0) {} // do nothing
    else if (exitCode == 2) {
      throw new RuntimeException("detekt: Max issues was reached ")
    } else if (exitCode == 3) {
      throw new RuntimeException("detekt: Invalid configuration file detected")
    }
    else {
      throw new RuntimeException(s"detekt exited abnormally with exit code = $exitCode")
    }
  }

  /**
   * Classpath for running Dekekt.
   */
  private def detektClasspath: T[Loose.Agg[PathRef]] = T {
    defaultResolver().resolveDeps(
      Agg(ivy"io.gitlab.arturbosch.detekt:detekt-cli:${detektVersion()}")
    )
  }

  /**
   * Detekt version.
   */
  private def detektVersion: T[String] = T {
    "1.23.7"
  }
}

/** See Also: src/example/Foo.kt */

/** Usage

> ./mill detekt
error: ...Foo.kt:5:5: Function main is nested too deeply. [NestedBlockDepth]

*/
